(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{382:function(e,r,n){"use strict";n.r(r);var t=n(42),s=Object(t.a)({},(function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"jquery-延时对象deferred简单实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jquery-延时对象deferred简单实现"}},[e._v("#")]),e._v(" jQuery 延时对象Deferred简单实现")]),e._v(" "),n("h2",{attrs:{id:"介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),n("h3",{attrs:{id:"什么是deferred对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是deferred对象"}},[e._v("#")]),e._v(" 什么是deferred对象")]),e._v(" "),n("p",[e._v("deferred对象是一个延时对象，函数延迟到某个点才开始执行，改变执行状态的方法有两个（成功：resolve和失败：reject），分别对应两种执行回调（成功回调函数：done和失败回调函数fail）")]),e._v(" "),n("div",{staticClass:"language-javascirpt extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var wait = function() {\n        var der = $.Deferred(); //创建deferred对象\n        var test = function(){\n            console.log("111");\n            der.resolve("222") \n        }\n        test()\n        return der\n    }\n    $.when(wait())  //$.when()参数里面必须是deferred对象\n        .done(function(data){ \n            console.log("执行成功",data)    \n        })\n        .fail(function(){\n            console.log("执行失败")\n        })\n        \n//打印结果:\n//111\n//222 ys\n')])])]),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[e._v("#")]),e._v(" 实现")]),e._v(" "),n("p",[e._v("Defferred的实现跟jQuery内部Callbacks函数密不可分 "),n("a",{attrs:{href:"https://juejin.im/post/5d20401ff265da1bb67a39b1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Callbacks源码分析"),n("OutboundLink")],1),e._v("，要用到其内部的fireWith函数，该函数主要用于控制参数传递以及执行list中的所有回调函数。")]),e._v(" "),n("div",{staticClass:"language-javascirpt extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Deferred: function(func){\n    //tuples数组储存延迟对象的不同状态信息描述\n    var tuples = [\n        ["resolve", "done", jQuery.Callbacks("once memory")],\n        ["reject", "fail", jQuery.Callbacks("once memory")]\n    ],\n    promise = {\n        then(){\n        },\n        promise(obj){\n            return obj != null ? jQuery.extend(obj, promise) : promise\n        }\n    },\n    \n    //延迟对象\n    deferred = {}\n\n    tuples.forEach((tuple, i)=>{\n        //创建Callbacks队列函数，list=jQuery.Callbacks("once memory")\n        var list = tuple[2]\n        \n        //扩展promise对象，promise[ done | fail ] = list.add\n        //调用done,fail,progress会给队列里面添加处理函数\n        promise[tuple[1]] = list.add\n\n        //给deferred扩展resolve,reject\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n        deferred[tuple[0]] = function(){\n            //给fireWith传递参数，指定this\n            deferred[tuple[0] + "With"](this === deferred ? promise : this , arguments)\n            return this\n        }\n\n        deferred[tuple[0] + "With"] = list.fireWith\n    })\n    \n    //扩展deferred属性，相当于合并promise跟deferred,\n    //基本数据类型传参是按值传递，不会改变原对象。引用数据类型按对象传递、按对象共享传递，该方法会改变实参deferred\n    // deferred对象上面包含 resolve | reject | promise | done | fail | rejectWith | resolveWith 这些方法\n    promise.promise(deferred)\n\n    return deferred\n}\n//接受延迟对象的回调函数，返回的是promise对象\nwhen(deferred){\n    return deferred.promise()\n}\n')])])]),n("p",[e._v("以上基本能实现deferred对象功能，包含resolve()及reject两个处理函数")]),e._v(" "),n("p",[e._v("deferred对象包含的方法包括 resolve | reject | promise | done | fail | rejectWith | resolveWith")]),e._v(" "),n("p",[e._v("when()函数返回promise对象，其包括的方法有 done | fail | promise")]),e._v(" "),n("p",[e._v("当执行deferred对象的resolve()方法，相当于执行了deferred.resolveWith()，也就是Callbacks里面的fireWith函数，执行Callbacks队列函数的所有回调函数。deferred.resolve() -> deferred.resolveWith() -> list.fireWith() -> list.fire()")]),e._v(" "),n("p",[e._v('回调函数添加进入Callbacks队列函数是通过 promis.done(回调函数) 添加，promise[tuple[1]] = list.add, 由于创建Callbacks传入了memory参数，jQuery.Callbacks("once memory")，它会在添加函数的同时执行Callbacks队列函数')]),e._v(" "),n("div",{staticClass:"language-javascirpt extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var wait = function() {\n    var der = $.Deferred(); //创建deferred对象\n    var test = function(){\n        console.log("111");\n        der.resolve("222") //执行Callbacks队列函数添加回调函数\n    }\n    test()\n    return der\n}\n$.when(wait())  //$.when()参数里面必须是deferred对象，返回的是promise对象\n    .done(function(data){   //向Callbacks队列函数添加回调函数,并执行队列函数\n        console.log("执行成功",data)\n    })\n    .fail(function(){\n        console.log("执行失败")\n    })\n    \n//打印结果:\n//111\n//222 ys\n')])])]),n("p",[e._v("以上便基本实现了Deferred对象，当然Deferred本身还不仅仅是这些，Deferrred最复杂深奥的代码在promise.then里面，本文没有分析，有空再深入")])])}),[],!1,null,null,null);r.default=s.exports}}]);